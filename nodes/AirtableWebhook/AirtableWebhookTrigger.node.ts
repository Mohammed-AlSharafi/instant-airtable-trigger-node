import {
	IHookFunctions,
	IWebhookFunctions,
	IDataObject,
	INodeType,
	INodeTypeDescription,
	IWebhookResponseData,
	NodeConnectionType
} from 'n8n-workflow';

import { airtableApiRequest } from './GenericFunctions';

export class AirtableWebhookTrigger implements INodeType {
	description: INodeTypeDescription = {
		displayName: 'Airtable Webhook Trigger',
		name: 'airtableWebhookTrigger',
		icon: 'file:airtable.svg',
		group: ['trigger'],
		version: 1,
		description: 'Handle Airtable events via webhooks',
		defaults: {
			name: 'Airtable Webhook Trigger',
		},
		inputs: [],
		outputs: [NodeConnectionType.Main],
		credentials: [
			{
				name: 'airtableApi',
				required: true,
			},
		],
		webhooks: [
			{
				name: 'default',
				httpMethod: 'POST',
				responseMode: 'onReceived',
				path: 'webhook',
			},
		],
		properties: [
			{
				displayName: 'Base ID',
				name: 'baseId',
				type: 'string',
				default: '',
				required: true,
				description: 'The ID of the base to register the webhook for',
			},
			{
				displayName: 'Data Types',
				name: 'dataTypes',
				type: 'multiOptions',
				options: [
					{
						name: 'Table Data',
						value: 'tableData',
						description: 'Record and cell value changes',
					},
					{
						name: 'Table Fields',
						value: 'tableFields',
						description: 'Field changes',
					},
					{
						name: 'Table Metadata',
						value: 'tableMetadata',
						description: 'Table name and description changes',
					},
				],
				default: ['tableData'],
				required: true,
				description: 'The types of data to watch for changes',
			},
			{
				displayName: 'Record Change Scope',
				name: 'recordChangeScope',
				type: 'string',
				default: '',
				description: 'The ID of the table or view to watch for changes. Leave empty to watch the entire base.',
			},
			{
				displayName: 'Advanced Options',
				name: 'advancedOptions',
				type: 'collection',
				placeholder: 'Add Option',
				default: {},
				options: [
					{
						displayName: 'Change Types',
						name: 'changeTypes',
						type: 'multiOptions',
						options: [
							{
								name: 'Add',
								value: 'add',
							},
							{
								name: 'Remove',
								value: 'remove',
							},
							{
								name: 'Update',
								value: 'update',
							},
						],
						default: [],
						description: 'Only generate payloads for specific change types',
					},
					{
						displayName: 'From Sources',
						name: 'fromSources',
						type: 'multiOptions',
						options: [
							{
								name: 'Anonymous User',
								value: 'anonymousUser',
							},
							{
								name: 'Automation',
								value: 'automation',
								description: 'Changes generated through an automation action',
							},
							{
								name: 'Client',
								value: 'client',
								description: 'Changes generated by a user through the web or mobile clients',
							},
							{
								name: 'Form Page Submission',
								value: 'formPageSubmission',
								description: 'Changes from interface form builders',
							},
							{
								name: 'Form Submission',
								value: 'formSubmission',
								description: 'Changes generated when a form view is submitted',
							},
							{
								name: 'Public API',
								value: 'publicApi',
								description: 'Changes generated through the Airtable API',
							},
							{
								name: 'Sync',
								value: 'sync',
								description: 'Changes generated through Airtable Sync',
							},
							{
								name: 'System',
								value: 'system',
								description: 'Changes generated by system events',
							},
							{
								name: 'Unknown',
								value: 'unknown',
							},
						],
						default: [],
						description: 'Only generate payloads for changes from specific sources',
					},
					{
						displayName: 'Include Cell Values In Field IDs',
						name: 'includeCellValuesInFieldIds',
						type: 'string',
						default: '',
						description: 'Comma-separated list of field IDs to include values for, regardless of whether they changed',
					},
					{
						displayName: 'Include Previous Cell Values',
						name: 'includePreviousCellValues',
						type: 'boolean',
						default: false,
						description: 'Whether to include the previous cell values in the webhook payload',
					},
					{
						displayName: 'Include Previous Field Definitions',
						name: 'includePreviousFieldDefinitions',
						type: 'boolean',
						default: false,
						description: 'Whether to include the previous field definitions in the webhook payload',
					},
					{
						displayName: 'Watch Data In Field IDs',
						name: 'watchDataInFieldIds',
						type: 'string',
						default: '',
						description: 'Comma-separated list of field IDs to watch for changes',
					},
				],
			},
		],
	};

	webhookMethods = {
		default: {
			async checkExists(this: IHookFunctions): Promise<boolean> {
				const webhookData = this.getWorkflowStaticData('node');
				const baseId = this.getNodeParameter('baseId') as string;

				console.log('Checking if webhook exists, webhookId:', webhookData.webhookId);
				
				// If we don't have a webhookId stored, it can't exist
				if (webhookData.webhookId === undefined) {
					return false;
				}

				try {
					// Get all webhooks for the base
					const endpoint = `/bases/${baseId}/webhooks`;
					const response = await airtableApiRequest.call(this, 'GET', endpoint);
					console.log('Webhooks list response:', JSON.stringify(response));
					
					// Check if our webhook ID exists in the list
					if (response.webhooks) {
						for (const webhook of response.webhooks) {
							if (webhook.id === webhookData.webhookId) {
								console.log('Webhook found, exists:', webhook);
								return true;
							}
						}
					}
					
					console.log('Webhook not found in list');
					return false;
				} catch (error) {
					console.log('Error checking webhook existence:', error);
					return false;
				}
			},

			async create(this: IHookFunctions): Promise<boolean> {
				const webhookUrl = this.getNodeWebhookUrl('default');
				const webhookData = this.getWorkflowStaticData('node');
				const baseId = this.getNodeParameter('baseId') as string;
				const dataTypes = this.getNodeParameter('dataTypes', []) as string[];
				const recordChangeScope = this.getNodeParameter('recordChangeScope', '') as string;
				const advancedOptions = this.getNodeParameter('advancedOptions', {}) as IDataObject;

				console.log('Creating webhook with URL:', webhookUrl);
				console.log('Base ID:', baseId);
				console.log('Data Types:', dataTypes);
				console.log('Record Change Scope:', recordChangeScope);
				console.log('Advanced Options:', JSON.stringify(advancedOptions));

				// Build the webhook specification
				const specification: IDataObject = {
					options: {
						filters: {
							dataTypes,
						},
					},
				};

				// Add record change scope if specified
				if (recordChangeScope) {
					(specification.options as IDataObject).filters = {
						...(specification.options as IDataObject).filters as IDataObject,
						recordChangeScope,
					};
				}

				// Add advanced options if specified
				if (advancedOptions.changeTypes && Array.isArray(advancedOptions.changeTypes) && advancedOptions.changeTypes.length > 0) {
					(specification.options as IDataObject).filters = {
						...(specification.options as IDataObject).filters as IDataObject,
						changeTypes: advancedOptions.changeTypes,
					};
				}

				if (advancedOptions.fromSources && Array.isArray(advancedOptions.fromSources) && advancedOptions.fromSources.length > 0) {
					(specification.options as IDataObject).filters = {
						...(specification.options as IDataObject).filters as IDataObject,
						fromSources: advancedOptions.fromSources,
					};
				}

				if (advancedOptions.watchDataInFieldIds) {
					const fieldIds = (advancedOptions.watchDataInFieldIds as string).split(',').map(id => id.trim());
					if (fieldIds.length > 0) {
						(specification.options as IDataObject).filters = {
							...(specification.options as IDataObject).filters as IDataObject,
							watchDataInFieldIds: fieldIds,
						};
					}
				}

				// Add includes if specified
				const includesOptions: IDataObject = {};
				
				if (advancedOptions.includePreviousCellValues === true) {
					includesOptions.includePreviousCellValues = true;
				}

				if (advancedOptions.includePreviousFieldDefinitions === true) {
					includesOptions.includePreviousFieldDefinitions = true;
				}

				if (advancedOptions.includeCellValuesInFieldIds) {
					const fieldIds = (advancedOptions.includeCellValuesInFieldIds as string).split(',').map(id => id.trim());
					if (fieldIds.length > 0) {
						includesOptions.includeCellValuesInFieldIds = fieldIds;
					}
				}

				// Only add includes if we have at least one option
				if (Object.keys(includesOptions).length > 0) {
					(specification.options as IDataObject).includes = includesOptions;
				}

				const body: IDataObject = {
					specification,
				};

				// Add notification URL if available
				if (webhookUrl) {
					body.notificationUrl = webhookUrl;
				}

				console.log('Webhook creation request body:', JSON.stringify(body, null, 2));

				try {
					// Create the webhook
					const endpoint = `/bases/${baseId}/webhooks`;
					const response = await airtableApiRequest.call(this, 'POST', endpoint, body);
					
					console.log('Webhook creation response:', JSON.stringify(response, null, 2));
					
					// Store webhook data
					webhookData.webhookId = response.id;
					webhookData.macSecretBase64 = response.macSecretBase64;
					webhookData.baseId = baseId;
					
					return true;
				} catch (error) {
					console.log('Webhook creation error:', error);
					throw error;
				}
			},

			async delete(this: IHookFunctions): Promise<boolean> {
				const webhookData = this.getWorkflowStaticData('node');
				const baseId = webhookData.baseId || this.getNodeParameter('baseId') as string;

				// If we don't have a webhookId, there's nothing to delete
				if (webhookData.webhookId === undefined) {
					return true;
				}

				try {
					console.log('Deleting webhook with ID:', webhookData.webhookId);
					// Delete the webhook
					const endpoint = `/bases/${baseId}/webhooks/${webhookData.webhookId}`;
					await airtableApiRequest.call(this, 'DELETE', endpoint);
					
					// Clear webhook data
					delete webhookData.webhookId;
					delete webhookData.macSecretBase64;
					delete webhookData.baseId;
					
					return true;
				} catch (error) {
					console.log('Webhook deletion error:', error);
					return false;
				}
			},
		},
	};

	async webhook(this: IWebhookFunctions): Promise<IWebhookResponseData> {
		const webhookData = this.getWorkflowStaticData('node');
		const req = this.getRequestObject();
		const headerData = this.getHeaderData();
		const body = req.body as IDataObject;

		console.log('Received webhook payload:', JSON.stringify(body, null, 2));
		console.log('Headers:', JSON.stringify(headerData, null, 2));

		// Verify the webhook signature if available
		if (webhookData.macSecretBase64 && headerData['x-airtable-signature']) {
			const signature = headerData['x-airtable-signature'] as string;
			
			// Import createHmac only when needed to avoid unused import error
			const { createHmac } = await import('crypto');
			
			const computedSignature = createHmac('sha256', Buffer.from(webhookData.macSecretBase64 as string, 'base64'))
				.update(req.rawBody)
				.digest('base64');
			
			console.log('Expected signature:', computedSignature);
			console.log('Received signature:', signature);
			
			if (signature !== computedSignature) {
				console.log('Invalid signature, ignoring webhook');
				return {};
			}
		}

		// Process the webhook payload
		return {
			workflowData: [this.helpers.returnJsonArray(body)],
		};
	}
}